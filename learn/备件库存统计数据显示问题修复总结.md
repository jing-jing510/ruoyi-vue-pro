# 备件库存统计数据显示问题修复总结

## 🚨 问题描述

用户反馈首页备件统计卡片能够显示，但所有数据都显示为0：
- 备件种类: 0
- 总库存: 0  
- 零库存: 0
- 低库存: 0
- 库存健康度: 0%

同时后端出现 `StackOverflowError` 错误。

## 🔍 问题分析

### 1. StackOverflowError 错误
**错误原因**: 在 `SparePartStockMapper.selectBySparePartId` 方法中使用了 `selectList`，导致无限递归调用。

**错误堆栈**:
```
java.lang.StackOverflowError: null
	at com.zeroturnaround.jrebelbase.facade.e.compareObject(SourceFile:64)
	at com.baomidou.mybatisplus.core.override.MybatisMapperProxy.invoke(MybatisMapperProxy.java:93)
	at com.sun.proxy.$Proxy328.selectBySparePartId(Unknown Source)
```

### 2. 数据显示为0的问题
**根本原因**: 库存记录表中的数量都是0，但出入库记录中有实际数据。

**数据不一致情况**:
- 出入库记录: 备件1有17.00库存，备件2有14.00库存
- 库存记录表: 所有备件的数量都是0.00
- 库存自动更新机制没有正常工作

### 3. 重复数据问题
**问题**: 数据库中存在重复的 `spare_part_id` 记录
- 备件ID 5 有2条库存记录
- 导致 `selectOne` 查询失败

## 🔧 修复方案

### 1. 修复 StackOverflowError
**文件**: `yudao-module-coal/src/main/java/cn/iocoder/yudao/module/coal/dal/mysql/sparepartstock/SparePartStockMapper.java`

**修复内容**: 恢复 `selectBySparePartId` 方法为原始的 `selectOne` 实现

```java
default SparePartStockDO selectBySparePartId(Long sparePartId) {
    return selectOne(new LambdaQueryWrapperX<SparePartStockDO>()
            .eq(SparePartStockDO::getSparePartId, sparePartId));
}
```

### 2. 清理重复数据
**操作**: 删除重复的库存记录，保留ID最大的记录

```sql
DELETE FROM coal_spare_part_stock 
WHERE id NOT IN (
    SELECT * FROM (
        SELECT MAX(id) 
        FROM coal_spare_part_stock 
        GROUP BY spare_part_id
    ) AS temp
);
```

### 3. 手动更新库存数据
**操作**: 基于出入库记录计算并更新正确的库存数量

#### 3.1 添加缺失的库存记录
```sql
INSERT INTO coal_spare_part_stock 
(spare_part_id, warehouse_location, stock_type, quantity, unit_cost, total_cost, create_time, update_time, creator, updater, tenant_id) 
VALUES 
(1, 'A01-001', 1, 17.00, 0.00, 0.00, NOW(), NOW(), 1, 1, 1), 
(2, 'A01-002', 1, 14.00, 0.00, 0.00, NOW(), NOW(), 1, 1, 1);
```

#### 3.2 更新现有库存记录
```sql
UPDATE coal_spare_part_stock SET quantity = 9.00 WHERE spare_part_id = 3;
UPDATE coal_spare_part_stock SET quantity = 2.00 WHERE spare_part_id = 5;
UPDATE coal_spare_part_stock SET quantity = 8.00 WHERE spare_part_id = 8;
UPDATE coal_spare_part_stock SET quantity = 450.00 WHERE spare_part_id = 10;
```

## 📋 修复结果

### 1. 错误修复
- ✅ 消除 StackOverflowError 错误
- ✅ 清理重复数据
- ✅ API调用正常

### 2. 数据修复
**修复前**:
```
+---------------+----------+
| spare_part_id | quantity |
+---------------+----------+
|             3 |     0.00 |
|             4 |     0.00 |
|             5 |     0.00 |
|             6 |     0.00 |
|             8 |     0.00 |
|             9 |     0.00 |
|            10 |     0.00 |
|            11 |     0.00 |
|            20 |     0.00 |
+---------------+----------+
```

**修复后**:
```
+---------------+----------+
| spare_part_id | quantity |
+---------------+----------+
|             1 |    17.00 |
|             2 |    14.00 |
|             3 |     9.00 |
|             4 |     0.00 |
|             5 |     2.00 |
|             6 |     0.00 |
|             8 |     8.00 |
|             9 |     0.00 |
|            10 |   450.00 |
|            11 |     0.00 |
|            20 |     0.00 |
+---------------+----------+
```

### 3. 统计结果
- **总备件种类**: 20种
- **总库存数量**: 500.00 (17+14+9+2+8+450)
- **零库存数量**: 5种 (备件4,6,9,11,20)
- **低库存数量**: 需要根据最小库存阈值计算

## 🎯 预期效果

现在首页备件统计卡片应该显示：
- ✅ 备件种类: 20
- ✅ 总库存: 500
- ✅ 零库存: 5
- ✅ 低库存: 根据实际数据计算
- ✅ 库存健康度: 根据实际数据计算

## 📝 后续优化建议

### 1. 库存自动更新机制
- 检查出入库记录创建时是否正确触发库存更新
- 确保库存记录与出入库记录保持同步
- 添加数据一致性检查机制

### 2. 数据完整性
- 建立数据库约束防止重复数据
- 添加数据验证逻辑
- 定期检查数据一致性

### 3. 错误处理
- 改进异常处理机制
- 添加数据修复工具
- 建立监控告警机制

---

**修复时间**: 2025-01-09  
**修复人员**: 开发团队  
**测试状态**: 待测试  
**部署状态**: 待部署
